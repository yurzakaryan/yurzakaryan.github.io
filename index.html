<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Drive & Shoot Prototype</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Press Start 2P', cursive;
            background-color: #555; /* Darker background for city */
        }
        #container {
            width: 100vw;
            height: 100vh;
            display: block;
            cursor: pointer; /* Indicate clickable area for pointer lock */
        }
        canvas {
            display: block; /* Prevent default inline display */
        }
        #blocker { /* Overlay instructions */
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #instructions {
           width: 80%;
           max-width: 450px; /* Wider instructions */
           padding: 20px;
           background-color: rgba(50, 50, 50, 0.8);
           color: white;
           border-radius: 10px;
           text-align: center;
           font-size: 12px;
           line-height: 1.6;
           z-index: 5;
           cursor: default;
        }
         #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
            display: none; /* Hidden until pointer lock */
        }
        /* Remove block selector UI */
        #block-selector { display: none; }

        /* Health Bar Styles (remain same) */
        #health-bar-container {
            position: absolute;
            bottom: 20px; /* Lower position */
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background-color: rgba(50, 50, 50, 0.7);
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            overflow: hidden;
            z-index: 5;
        }
        #health-bar {
            width: 100%;
            height: 100%;
            background-color: #dc3545;
            border-radius: 4px;
            transition: width 0.3s ease-in-out;
        }
        #health-text {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             color: white;
             text-align: center;
             font-size: 10px;
             line-height: 20px;
             text-shadow: 1px 1px 1px rgba(0,0,0,0.8);
        }
         /* Game Over Message (remain same) */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 30px;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 20;
        }
         #game-over button {
             font-family: 'Press Start 2P', cursive;
             font-size: 16px;
             padding: 10px 20px;
             margin-top: 20px;
             background-color: #555;
             color: white;
             border: 2px solid #888;
             border-radius: 5px;
             cursor: pointer;
             transition: background-color 0.2s;
         }
          #game-over button:hover {
              background-color: #777;
          }
          /* Speedometer */
         #speedometer {
             position: absolute;
             bottom: 50px;
             left: 20px;
             background-color: rgba(0, 0, 0, 0.5);
             color: white;
             padding: 8px 12px;
             border-radius: 5px;
             font-size: 14px;
             z-index: 5;
             display: none; /* Hidden initially */
         }

    </style>
</head>
<body class="bg-gray-700"> {/* Changed background */}
    <div id="container">
        <div id="blocker">
            <div id="instructions">
                Click to Play<br><br>
                --- On Foot ---<br>
                W, A, S, D: Move<br>
                Space: Jump<br>
                Mouse: Look<br>
                Left Click: Shoot<br>
                F (near car): Enter/Exit Car<br> {/* Changed key */}
                ESC: Release Mouse<br><br>
                --- In Car ---<br>
                W / Up Arrow: Accelerate<br>
                S / Down Arrow: Brake/Reverse<br>
                A / Left Arrow: Turn Left<br>
                D / Right Arrow: Turn Right<br>
                F: Exit Car {/* Changed key */}
            </div>
        </div>
    </div>
    <div id="crosshair">+</div>
    <div id="health-bar-container">
        <div id="health-bar"></div>
        <div id="health-text">HP: 100 / 100</div>
    </div>
     <div id="speedometer">Speed: 0 km/h</div>
    <div id="game-over">
        <div>GAME OVER</div>
        <button id="restart-button">Restart</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
                "PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'PointerLockControls';

        // --- Configuration ---
        const MOVE_SPEED = 5.0;
        const JUMP_VELOCITY = 7.0;
        const GRAVITY = -15.0;
        const PLAYER_MAX_HEALTH = 100;
        const BULLET_SPEED = 40.0;
        const BULLET_DAMAGE = 15;
        const BULLET_LIFETIME = 1.5;
        const ENEMY_HEALTH = 60;
        const ENEMY_SPAWN_COUNT = 8;
        const ENEMY_DAMAGE = 10; // Melee damage
        const ENEMY_ATTACK_COOLDOWN = 1.5;
        const ENEMY_ATTACK_RANGE_SQ = 2.0 * 2.0;
        const ENEMY_MOVE_SPEED = 2.0;
        const ENEMY_SHOOT_COOLDOWN = 2.5; // How often enemies shoot
        const ENEMY_SHOOT_RANGE = 25.0; // How far enemies can shoot
        const ENEMY_BULLET_SPEED = 20.0;
        const ENEMY_BULLET_DAMAGE = 8;

        // Car Configuration
        const CAR_ACCELERATION = 15.0;
        const CAR_BRAKING = 30.0;
        const CAR_MAX_SPEED = 60.0;
        const CAR_TURN_SPEED = 1.5;
        const CAR_FRICTION = 0.98;
        const CAR_ENTER_RANGE_SQ = 3 * 3;
        const TRAFFIC_CAR_SPEED = 10.0;
        const TRAFFIC_CAR_COUNT = 10;
        const TRAFFIC_TURN_CHANCE = 0.1; // Chance to turn at intersection

        // City Configuration
        const CITY_SIZE = 100;
        const ROAD_WIDTH = 8;
        const BUILDING_MIN_HEIGHT = 10;
        const BUILDING_MAX_HEIGHT = 40;
        const BUILDING_SIZE = 8;
        const NUM_ROADS = 5;

        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let environmentObjects = []; // Roads, buildings, ground
        let projectiles = []; // Player and enemy bullets
        let enemies = [];
        let cars = []; // Includes player car and traffic cars
        let playerCar = null; // Reference to the car the player is currently driving
        let playerVelocity = new THREE.Vector3();
        let onGround = false;
        let clock = new THREE.Clock();
        let keys = {};
        let raycaster = new THREE.Raycaster(); // Reusable raycaster
        let mouse = new THREE.Vector2(0, 0);
        let playerHealth = PLAYER_MAX_HEALTH;
        let isGameOver = false;
        let animationFrameId;
        let isInCar = false;
        let weaponModel;

        // DOM Elements
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const crosshair = document.getElementById('crosshair');
        const container = document.getElementById('container');
        const healthBar = document.getElementById('health-bar');
        const healthText = document.getElementById('health-text');
        const gameOverScreen = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const speedometer = document.getElementById('speedometer');

        // --- Geometries & Materials (Cached) ---
        const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const enemyBulletGeometry = new THREE.SphereGeometry(0.12, 8, 8); // Slightly larger enemy bullets
        const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const bodyGeo = new THREE.BoxGeometry(0.8, 1.0, 0.4);

        const playerBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // Yellow player bullets
        const enemyBulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff8800 }); // Orange enemy bullets
        const enemyBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x0055aa });
        const roadMaterial = new THREE.MeshStandardMaterial({ color: 0x404040, side: THREE.DoubleSide });
        const buildingMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const playerCarMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const trafficCarMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x505050 });


        // Bounding Boxes for faster checks
        const bulletBoundingBox = new THREE.Box3();
        const enemyBoundingBox = new THREE.Box3();
        const carBoundingBox = new THREE.Box3();
        const buildingBoundingBox = new THREE.Box3(); // For checking impassability

        // --- Capsule Class Definition (Standalone) ---
        class Capsule {
            constructor(start = new THREE.Vector3(0, 0, 0), end = new THREE.Vector3(0, 1, 0), radius = 1) {
                this.start = start; this.end = end; this.radius = radius;
                this.line = new THREE.Line3(this.start, this.end);
            }
            intersectsBox(box) { /* ... (implementation unchanged) ... */
                const startSphere = new THREE.Sphere(this.start, this.radius);
                const endSphere = new THREE.Sphere(this.end, this.radius);
                if (box.intersectsSphere(startSphere) || box.intersectsSphere(endSphere)) return true;
                const closestPointOnLine = new THREE.Vector3();
                const closestPointOnBox = new THREE.Vector3();
                box.clampPoint(this.start, closestPointOnBox);
                if(closestPointOnBox.distanceToSquared(this.start) <= this.radius * this.radius) return true;
                box.clampPoint(this.end, closestPointOnBox);
                if(closestPointOnBox.distanceToSquared(this.end) <= this.radius * this.radius) return true;
                this.line.closestPointToPoint(box.getCenter(new THREE.Vector3()), true, closestPointOnLine);
                box.clampPoint(closestPointOnLine, closestPointOnBox);
                if(closestPointOnBox.distanceToSquared(closestPointOnLine) <= this.radius * this.radius) return true;
                return false;
             }
            getPenetration(box) { /* ... (implementation unchanged) ... */
                 const penetration = new THREE.Vector3(); if (!this.intersectsBox(box)) return penetration;
                 const boxCenter = box.getCenter(new THREE.Vector3());
                 const closestPointOnLine = new THREE.Vector3(); this.line.closestPointToPoint(boxCenter, true, closestPointOnLine);
                 const closestPointOnBox = new THREE.Vector3(); box.clampPoint(closestPointOnLine, closestPointOnBox);
                 penetration.subVectors(closestPointOnLine, closestPointOnBox);
                 const dist = penetration.length(); const overlap = this.radius - dist;
                 if (overlap > 0) {
                     if (dist > 1e-6) { penetration.multiplyScalar(overlap / dist); }
                     else { const capsuleCenter = new THREE.Vector3().addVectors(this.start, this.end).multiplyScalar(0.5); penetration.subVectors(capsuleCenter, boxCenter).setLength(overlap); }
                 } else { penetration.set(0, 0, 0); }
                 return penetration;
             }
        }

        // --- Enemy Management (Defined BEFORE init) ---
        function createEnemyMesh() { /* ... (implementation unchanged) ... */
            const enemyGroup = new THREE.Group();
            const body = new THREE.Mesh(bodyGeo, enemyBodyMaterial); body.position.y = 0.5; body.castShadow = true; enemyGroup.add(body);
            const head = new THREE.Mesh(headGeo, enemyBodyMaterial); head.position.y = 1.25; head.castShadow = true; enemyGroup.add(head);
            return enemyGroup;
         }

        function spawnEnemy(x, z) { /* ... (implementation largely unchanged, added shoot cooldown) ... */
            if (!scene) { console.error("Scene not initialized during spawnEnemy call."); return; }
            try {
                const enemy = createEnemyMesh();
                let startY = 30; let foundSurface = false; const downRay = new THREE.Raycaster();
                while(startY > -20 && !foundSurface) {
                    downRay.set(new THREE.Vector3(x, startY, z), new THREE.Vector3(0, -1, 0));
                    const intersects = downRay.intersectObjects(environmentObjects, false);
                    if (intersects.length > 0) { enemy.position.set(x, intersects[0].point.y + 1.0, z); foundSurface = true; }
                    startY--;
                }
                if (!foundSurface) { enemy.position.set(x, 1.0, z); }
                enemy.userData = { type: 'enemy', health: ENEMY_HEALTH, lastAttackTime: 0, lastShootTime: 0 }; // Added lastShootTime
                scene.add(enemy); enemies.push(enemy);
            } catch (e) { console.error("Error spawning enemy:", e); }
         }

        function spawnEnemies(count) { /* ... (implementation unchanged) ... */
            const worldHalf = CITY_SIZE / 2 - 2; let attempts = 0;
            const playerPosCheck = controls ? controls.getObject().position : new THREE.Vector3(0,0,0);
            for (let i = 0; i < count && attempts < count * 5; attempts++) {
                const x = THREE.MathUtils.randFloat(-worldHalf, worldHalf); const z = THREE.MathUtils.randFloat(-worldHalf, worldHalf);
                const spawnPos = new THREE.Vector3(x, 1, z); let isInsideBuilding = false;
                const roadSpacing = CITY_SIZE / (NUM_ROADS + 1);
                const buildingCheckX = Math.abs(x) % roadSpacing; const buildingCheckZ = Math.abs(z) % roadSpacing;
                if (buildingCheckX > ROAD_WIDTH / 2 && buildingCheckZ > ROAD_WIDTH / 2) { isInsideBuilding = true; }
                if (!isInsideBuilding && spawnPos.distanceTo(playerPosCheck) > 15) { spawnEnemy(x, z); i++; }
            }
            if (attempts >= count * 5) { console.warn("Could not spawn all enemies due to placement issues."); }
         }

        function removeEnemy(enemy) { /* ... (implementation unchanged) ... */
             if (!enemy) return; const index = enemies.indexOf(enemy); if (index > -1) enemies.splice(index, 1);
             if (scene) scene.remove(enemy); enemy.traverse(child => { if (child.isMesh) { /* Dispose */ } });
         }


        // --- Initialization ---
        function init() { /* ... (implementation largely unchanged) ... */
            console.log("Initializing game...");
            isGameOver = false; isInCar = false; playerHealth = PLAYER_MAX_HEALTH;
            updateHealthBar(); gameOverScreen.style.display = 'none'; blocker.style.display = 'flex';
            instructions.style.display = ''; crosshair.style.display = 'none'; speedometer.style.display = 'none';
            clearScene();
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x555); scene.fog = new THREE.Fog(0x555, 20, CITY_SIZE * 0.8);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            if (!renderer) { try { renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; const renderContainer = document.getElementById('container'); if (renderContainer) renderContainer.appendChild(renderer.domElement); else { console.error("Container element not found!"); return; } } catch (e) { console.error("Failed to initialize WebGL Renderer:", e); alert("Could not initialize WebGL."); return; } } else { renderer.setSize(window.innerWidth, window.innerHeight); }
            const ambientLight = new THREE.AmbientLight(0xaaaaaa); scene.add(ambientLight);
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0); sunLight.position.set(100, 150, 100); sunLight.castShadow = true; sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048; sunLight.shadow.camera.near = 10; sunLight.shadow.camera.far = 300; sunLight.shadow.camera.left = -CITY_SIZE; sunLight.shadow.camera.right = CITY_SIZE; sunLight.shadow.camera.top = CITY_SIZE; sunLight.shadow.camera.bottom = -CITY_SIZE; scene.add(sunLight);
            createCity();
            // Spawn Player Car - Ensure it's not marked as isPlayer initially
            const initialPlayerCar = createCar(0, 0.5, 5, playerCarMaterial);
            // Don't set isPlayer here, handle it when entering
            cars.push(initialPlayerCar);
            spawnTraffic(TRAFFIC_CAR_COUNT);
            controls = new PointerLockControls(camera, document.body); controls.getObject().position.set(2, 1.8, 8); scene.add(controls.getObject()); setupPointerLockEvents();
            createWeaponModel();
            playerVelocity.set(0, 0, 0); onGround = false;
            setupEventListeners();
            spawnEnemies(ENEMY_SPAWN_COUNT);
            console.log("Initialization complete."); if (!animationFrameId) animate();
         }

        // --- Scene Clearing ---
        function clearScene() { /* ... (implementation unchanged) ... */
            console.log("Clearing scene..."); if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
            [...projectiles, ...enemies, ...environmentObjects, ...cars].forEach(obj => { if (obj && scene) { scene.remove(obj); } });
            projectiles = []; enemies = []; environmentObjects = []; cars = []; playerCar = null;
            if (controls && controls.getObject() && scene && scene.children.includes(controls.getObject())) { scene.remove(controls.getObject()); }
            if (weaponModel && camera && camera.children.includes(weaponModel)) { camera.remove(weaponModel); } weaponModel = null;
            console.log("Scene cleared.");
         }

        // --- City Generation ---
        function createCity() { /* ... (implementation unchanged, includes ground plane) ... */
            const cityHalf = CITY_SIZE / 2;
            const groundGeo = new THREE.PlaneGeometry(CITY_SIZE, CITY_SIZE); const groundMesh = new THREE.Mesh(groundGeo, groundMaterial); groundMesh.rotation.x = -Math.PI / 2; groundMesh.position.y = -0.05; groundMesh.receiveShadow = true; scene.add(groundMesh); environmentObjects.push(groundMesh);
            const roadGeo = new THREE.PlaneGeometry(CITY_SIZE, ROAD_WIDTH); const roadGeoCross = new THREE.PlaneGeometry(ROAD_WIDTH, CITY_SIZE); const roadSpacing = CITY_SIZE / (NUM_ROADS + 1);
            for (let i = 1; i <= NUM_ROADS; i++) { const roadZ = new THREE.Mesh(roadGeo, roadMaterial); roadZ.rotation.x = -Math.PI / 2; roadZ.position.x = (i * roadSpacing) - cityHalf; roadZ.position.y = 0; roadZ.receiveShadow = true; scene.add(roadZ); environmentObjects.push(roadZ); const roadX = new THREE.Mesh(roadGeoCross, roadMaterial); roadX.rotation.x = -Math.PI / 2; roadX.position.z = (i * roadSpacing) - cityHalf; roadX.position.y = 0; roadX.receiveShadow = true; scene.add(roadX); environmentObjects.push(roadX); }
            const cityBlocks = NUM_ROADS + 1; const blockOriginOffset = cityHalf - (roadSpacing / 2);
            for (let bx = 0; bx < cityBlocks; bx++) { for (let bz = 0; bz < cityBlocks; bz++) { const buildingX = (bx * roadSpacing) - blockOriginOffset; const buildingZ = (bz * roadSpacing) - blockOriginOffset; let onIntersection = false; for (let i = 1; i <= NUM_ROADS; i++) { const roadPosX = (i * roadSpacing) - cityHalf; const roadPosZ = (i * roadSpacing) - cityHalf; if (Math.abs(buildingX - roadPosX) < ROAD_WIDTH / 2 && Math.abs(buildingZ - roadPosZ) < ROAD_WIDTH / 2) { onIntersection = true; break; } } if (onIntersection) continue; if (Math.random() > 0.2) { const height = THREE.MathUtils.randFloat(BUILDING_MIN_HEIGHT, BUILDING_MAX_HEIGHT); const buildingGeo = new THREE.BoxGeometry(BUILDING_SIZE, height, BUILDING_SIZE); const building = new THREE.Mesh(buildingGeo, buildingMaterial); building.position.set(buildingX, height / 2, buildingZ); building.castShadow = true; building.receiveShadow = true; scene.add(building); environmentObjects.push(building); } } }
         }

        // --- Car Creation & Management ---
        function createCar(x, y, z, material) { /* ... (implementation unchanged) ... */
            const carBodyGeo = new THREE.BoxGeometry(2, 0.8, 4); const carTopGeo = new THREE.BoxGeometry(1.6, 0.6, 2.5); const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
            const car = new THREE.Group(); const body = new THREE.Mesh(carBodyGeo, material); body.position.y = 0.4; body.castShadow = true; car.add(body);
            const top = new THREE.Mesh(carTopGeo, material); top.position.y = 1.0; top.position.z = -0.3; top.castShadow = true; car.add(top);
            const wheelPositions = [ { x: -0.8, y: 0.4, z: 1.3 }, { x: 0.8, y: 0.4, z: 1.3 }, { x: -0.8, y: 0.4, z: -1.3 }, { x: 0.8, y: 0.4, z: -1.3 } ];
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 }); wheelPositions.forEach(pos => { const wheel = new THREE.Mesh(wheelGeo, wheelMaterial); wheel.rotation.z = Math.PI / 2; wheel.position.set(pos.x, pos.y, pos.z); car.add(wheel); });
            car.position.set(x, y, z); scene.add(car);
            car.userData = { type: 'car', speed: 0, steering: 0, velocity: new THREE.Vector3(), isPlayerControlled: false, /* Changed from isPlayer */ trafficDirection: new THREE.Vector3(0, 0, 1), trafficTargetPos: null };
            return car;
         }

        function spawnTraffic(count) { /* ... (implementation unchanged) ... */
            const cityHalf = CITY_SIZE / 2 - ROAD_WIDTH; const roadSpacing = CITY_SIZE / (NUM_ROADS + 1);
            for (let i = 0; i < count; i++) { let x, z, direction; const roadIndex = THREE.MathUtils.randInt(1, NUM_ROADS); const isOnXRoad = Math.random() < 0.5; if (isOnXRoad) { x = THREE.MathUtils.randFloat(-cityHalf, cityHalf); z = (roadIndex * roadSpacing) - cityHalf; direction = new THREE.Vector3(Math.random() < 0.5 ? 1 : -1, 0, 0); } else { x = (roadIndex * roadSpacing) - cityHalf; z = THREE.MathUtils.randFloat(-cityHalf, cityHalf); direction = new THREE.Vector3(0, 0, Math.random() < 0.5 ? 1 : -1); } const car = createCar(x, 0.5, z, trafficCarMaterial); car.userData.trafficDirection = direction; car.rotation.y = Math.atan2(direction.x, direction.z); cars.push(car); }
         }

        function updateCars(delta) {
            const cityLimit = CITY_SIZE / 2 + 10; // Wrap margin
            const roadSpacing = CITY_SIZE / (NUM_ROADS + 1);
            const cityHalf = CITY_SIZE / 2;

            cars.forEach(car => {
                if (!car || !car.userData) return;

                // --- Player Controlled Car ---
                if (car.userData.isPlayerControlled && isInCar) {
                    // Physics logic (unchanged from previous version)
                    let accelerationInput = 0; let turn = 0;
                    if (keys['KeyW'] || keys['ArrowUp']) accelerationInput = 1; if (keys['KeyS'] || keys['ArrowDown']) accelerationInput = -1;
                    if (keys['KeyA'] || keys['ArrowLeft']) turn += CAR_TURN_SPEED; if (keys['KeyD'] || keys['ArrowRight']) turn -= CAR_TURN_SPEED;
                    car.rotation.y += turn * delta;
                    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
                    let actualAcceleration = 0;
                    if (accelerationInput > 0) { actualAcceleration = CAR_ACCELERATION; }
                    else if (accelerationInput < 0) { const currentSpeed = car.userData.velocity.length(); if (currentSpeed > 0.1) { const brakeDirection = car.userData.velocity.clone().normalize().multiplyScalar(-1); car.userData.velocity.addScaledVector(brakeDirection, CAR_BRAKING * delta); } else { actualAcceleration = -CAR_ACCELERATION * 0.5; } }
                    if (actualAcceleration !== 0) { car.userData.velocity.addScaledVector(forward, actualAcceleration * delta); }
                    const speed = car.userData.velocity.length(); const frictionMagnitude = speed * CAR_FRICTION * delta; const frictionForce = car.userData.velocity.clone().normalize().multiplyScalar(-frictionMagnitude);
                    if (speed > 0.1) { const velocityAfterFriction = car.userData.velocity.clone().add(frictionForce); if (velocityAfterFriction.dot(car.userData.velocity) > 0) { car.userData.velocity.add(frictionForce); } else { car.userData.velocity.set(0,0,0); } }
                    else if (accelerationInput === 0) { car.userData.velocity.set(0,0,0); }
                    car.position.addScaledVector(car.userData.velocity, delta);

                    // Collision logic (unchanged)
                    carBoundingBox.setFromObject(car).expandByScalar(-0.1); const collisionCheckObjects = [...environmentObjects, ...enemies, ...cars];
                    for (const obj of collisionCheckObjects) { if (obj === car || (obj.geometry && obj.geometry instanceof THREE.PlaneGeometry)) continue; const objBox = new THREE.Box3().setFromObject(obj); if (carBoundingBox.intersectsBox(objBox)) { console.log("Car collision!"); const centerCar = carBoundingBox.getCenter(new THREE.Vector3()); const centerObj = objBox.getCenter(new THREE.Vector3()); const pushDirection = centerCar.sub(centerObj).normalize(); pushDirection.y = 0; const sizeCar = carBoundingBox.getSize(new THREE.Vector3()); const sizeObj = objBox.getSize(new THREE.Vector3()); const overlapX = (sizeCar.x + sizeObj.x) / 2 - Math.abs(car.position.x - obj.position.x); const overlapZ = (sizeCar.z + sizeObj.z) / 2 - Math.abs(car.position.z - obj.position.z); const overlap = Math.min(overlapX, overlapZ); if (overlap > 0) { car.position.addScaledVector(pushDirection, overlap * 1.1); } car.userData.velocity.multiplyScalar(0.2); if (obj.userData && obj.userData.type === 'enemy') { removeEnemy(obj); } break; } }

                    // Update speedometer and camera
                    const speedKmh = car.userData.velocity.length() * 3.6; speedometer.textContent = `Speed: ${speedKmh.toFixed(0)} km/h`;
                    updateCameraTarget();

                }
                // --- Traffic Car Logic ---
                else if (!car.userData.isPlayerControlled) {
                    // Check if near an intersection
                    let nearIntersection = false;
                    let currentRoadX = -1, currentRoadZ = -1;
                    for (let i = 1; i <= NUM_ROADS; i++) {
                        const roadPosX = (i * roadSpacing) - cityHalf;
                        const roadPosZ = (i * roadSpacing) - cityHalf;
                        if (Math.abs(car.position.x - roadPosX) < ROAD_WIDTH * 0.6) currentRoadX = i; // On vertical road i
                        if (Math.abs(car.position.z - roadPosZ) < ROAD_WIDTH * 0.6) currentRoadZ = i; // On horizontal road i
                    }
                    nearIntersection = currentRoadX > 0 && currentRoadZ > 0; // True if on both road types

                    // Decide to turn?
                    if (nearIntersection && Math.random() < TRAFFIC_TURN_CHANCE) {
                        const possibleTurns = [];
                        const currentDir = car.userData.trafficDirection;
                        // Check possible turns based on current direction
                        if (Math.abs(currentDir.x) > 0.1) { // Moving along X
                            possibleTurns.push(new THREE.Vector3(0, 0, 1)); // Turn onto Z+
                            possibleTurns.push(new THREE.Vector3(0, 0, -1)); // Turn onto Z-
                        } else { // Moving along Z
                            possibleTurns.push(new THREE.Vector3(1, 0, 0)); // Turn onto X+
                            possibleTurns.push(new THREE.Vector3(-1, 0, 0)); // Turn onto X-
                        }
                        // Randomly pick a new direction
                        const newDirection = possibleTurns[Math.floor(Math.random() * possibleTurns.length)];
                        car.userData.trafficDirection = newDirection;
                        car.rotation.y = Math.atan2(newDirection.x, newDirection.z); // Align car
                        console.log("Traffic car turning!");
                    }

                    // Move car
                    const moveVector = car.userData.trafficDirection.clone().multiplyScalar(TRAFFIC_CAR_SPEED * delta);
                    car.position.add(moveVector);

                    // Wrap around city bounds
                    if (Math.abs(car.position.x) > cityLimit || Math.abs(car.position.z) > cityLimit) {
                        if (car.userData.trafficDirection.x !== 0 && Math.abs(car.position.x) > cityLimit) car.position.x *= -0.99;
                        if (car.userData.trafficDirection.z !== 0 && Math.abs(car.position.z) > cityLimit) car.position.z *= -0.99;
                    }
                }
            });
        }

        // --- Enter/Exit Any Car (Using 'F' Key) ---
        function enterExitCarByKey() {
            if (isGameOver) return;

            const playerPos = controls.getObject().position;

            if (isInCar) {
                // --- Exit Current Car ---
                if (!playerCar) return; // Should not happen if isInCar is true

                const exitOffset = new THREE.Vector3(1.5, 0, 0).applyQuaternion(playerCar.quaternion);
                const exitPos = playerCar.position.clone().add(exitOffset);
                exitPos.y = 1.8;

                // Check if exit position is clear
                let canExit = true;
                const exitCheckRadius = 0.5;
                const exitCheckObjects = [...environmentObjects, ...cars]; // Check against buildings and other cars
                for(const obj of exitCheckObjects) {
                    if (obj === playerCar || (obj.geometry && obj.geometry instanceof THREE.PlaneGeometry)) continue;
                    const objBox = new THREE.Box3().setFromObject(obj);
                    // A simple distance check might be sufficient here
                    if (objBox.distanceToPoint(exitPos) < exitCheckRadius) {
                        canExit = false;
                        console.log("Cannot exit car: Blocked!");
                        break;
                    }
                }

                if (canExit) {
                    controls.getObject().position.copy(exitPos);
                    isInCar = false;
                    playerCar.userData.isPlayerControlled = false; // Mark car as no longer player controlled
                    playerCar = null; // Clear player car reference
                    controls.enabled = true;
                    if (controls && !controls.isLocked) controls.lock();
                    speedometer.style.display = 'none';
                    if (weaponModel) weaponModel.visible = true;
                    camera.position.set(0,0,0); camera.rotation.set(0,0,0);
                    controls.getObject().add(camera);
                    console.log("Exited car");
                }

            } else {
                // --- Enter Nearest Car ---
                let closestCar = null;
                let minDistanceSq = CAR_ENTER_RANGE_SQ; // Start with max allowed distance

                cars.forEach(car => {
                    // Can only enter if it's not already being driven by the player
                    if (!car.userData.isPlayerControlled) {
                        const distanceSq = playerPos.distanceToSquared(car.position);
                        if (distanceSq < minDistanceSq) {
                            minDistanceSq = distanceSq;
                            closestCar = car;
                        }
                    }
                });

                if (closestCar) {
                    playerCar = closestCar; // Set this car as the player's current car
                    playerCar.userData.isPlayerControlled = true; // Mark as player controlled
                    isInCar = true;
                    controls.enabled = false;
                    if (controls && controls.isLocked) controls.unlock();
                    speedometer.style.display = 'block';
                    if (weaponModel) weaponModel.visible = false;
                    controls.getObject().remove(camera); // Detach camera
                    scene.add(camera); // Add camera directly to scene
                    console.log("Entered car");
                }
            }
        }


        // Update camera position and rotation when in car
        function updateCameraTarget() { /* ... (implementation unchanged) ... */
            if (isInCar && playerCar) { const carPos = playerCar.position; const carQuat = playerCar.quaternion; const relativeCamPos = new THREE.Vector3(0, 3, -6); const cameraPos = relativeCamPos.applyQuaternion(carQuat).add(carPos); camera.position.lerp(cameraPos, 0.1); const lookAtOffset = new THREE.Vector3(0, 1.0, 5); const lookAtPos = lookAtOffset.applyQuaternion(carQuat).add(carPos); camera.lookAt(lookAtPos); }
         }

        // --- Weapon Model ---
        function createWeaponModel() { /* ... (implementation unchanged) ... */
             const weaponGeo = new THREE.BoxGeometry(0.1, 0.15, 0.8); weaponModel = new THREE.Mesh(weaponGeo, weaponMaterial);
             weaponModel.position.set(0.3, -0.2, -0.5); weaponModel.rotation.y = -0.1; weaponModel.castShadow = true;
             camera.add(weaponModel); weaponModel.visible = !isInCar;
         }

        // --- Player Health & UI (gameOver, takeDamage, updateHealthBar remain same) ---
        function gameOver() { console.log("Game Over!"); isGameOver = true; if (controls) controls.unlock(); if (gameOverScreen) gameOverScreen.style.display = 'flex'; if (blocker) blocker.style.display = 'none'; }
        function takeDamage(amount) { if (isGameOver) return; playerHealth -= amount; updateHealthBar(); console.log(`Player took ${amount} damage. Health: ${playerHealth}`); if (playerHealth <= 0) gameOver(); }
        function updateHealthBar() { const healthPercentage = Math.max(0, playerHealth) / PLAYER_MAX_HEALTH; if (healthBar) healthBar.style.width = `${healthPercentage * 100}%`; if (healthText) healthText.textContent = `HP: ${Math.max(0, playerHealth)} / ${PLAYER_MAX_HEALTH}`; if (healthBar) { if (healthPercentage <= 0) { healthBar.style.backgroundColor = '#6c757d'; } else if (healthPercentage < 0.3) { healthBar.style.backgroundColor = '#ffc107'; } else if (healthPercentage < 0.6) { healthBar.style.backgroundColor = '#fd7e14'; } else { healthBar.style.backgroundColor = '#dc3545'; } } }

        // --- Restart Game ---
        function restartGame() { console.log("Restarting game..."); if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } init(); }

        // --- Shooting ---
        function shoot(isPlayer = true, origin, direction) {
            if (isGameOver) return;
            // Prevent shooting if player is in car (unless we add car weapons later)
            if (isPlayer && (isInCar || !controls || !controls.isLocked)) return;

            try {
                const bulletMaterialToUse = isPlayer ? playerBulletMaterial : enemyBulletMaterial;
                const bulletGeoToUse = isPlayer ? bulletGeometry : enemyBulletGeometry;
                const bulletSpeedToUse = isPlayer ? BULLET_SPEED : ENEMY_BULLET_SPEED;

                const bullet = new THREE.Mesh(bulletGeoToUse, bulletMaterialToUse);

                // Use provided origin and direction, or calculate from player camera if isPlayer
                let shootOrigin = origin;
                let shootDirection = direction;

                if (isPlayer) {
                    shootOrigin = controls.getObject().position.clone();
                    shootDirection = new THREE.Vector3();
                    camera.getWorldDirection(shootDirection);
                    // Offset player bullet slightly forward and down from camera center
                    bullet.position.copy(shootOrigin).addScaledVector(shootDirection, 0.2).add(new THREE.Vector3(0, -0.1, 0));
                } else {
                    // Offset enemy bullet slightly forward from enemy origin
                    bullet.position.copy(shootOrigin).addScaledVector(shootDirection, 0.6); // Start slightly ahead of enemy
                }


                bullet.userData = {
                    type: 'bullet',
                    isPlayerBullet: isPlayer, // Track who shot it
                    velocity: shootDirection.clone().multiplyScalar(bulletSpeedToUse),
                    spawnTime: clock.getElapsedTime()
                };

                if (scene) scene.add(bullet);
                projectiles.push(bullet);
            } catch (e) {
                console.error("Error shooting:", e);
            }
        }


        // --- Event Listeners Setup ---
        function setupPointerLockEvents() { /* ... (implementation unchanged) ... */
             const instructionsElement = document.getElementById('instructions'); if (instructionsElement) { const newInstructions = instructionsElement.cloneNode(true); instructionsElement.parentNode.replaceChild(newInstructions, instructionsElement); newInstructions.addEventListener('click', () => { if(controls && !isInCar) controls.lock() }, false); } else { console.warn("Instructions element not found during pointer lock setup."); }
             if (controls) { const lockHandler = () => { if (isInCar) return; const instructions = document.getElementById('instructions'); const blocker = document.getElementById('blocker'); const crosshair = document.getElementById('crosshair'); if (instructions) instructions.style.display = 'none'; if (blocker) blocker.style.display = 'none'; if (crosshair) crosshair.style.display = 'block'; }; const unlockHandler = () => { if (isGameOver) return; const instructions = document.getElementById('instructions'); const blocker = document.getElementById('blocker'); const crosshair = document.getElementById('crosshair'); if (blocker) blocker.style.display = 'flex'; if (instructions) instructions.style.display = ''; if (crosshair) crosshair.style.display = 'none'; }; controls.removeEventListener('lock', lockHandler); controls.addEventListener('lock', lockHandler); controls.removeEventListener('unlock', unlockHandler); controls.addEventListener('unlock', unlockHandler); }
         }

        let listenersAdded = false;
        function setupEventListeners() {
            if (listenersAdded) { if (restartButton && !restartButton.onclick) { restartButton.addEventListener('click', restartGame); } return; }
            window.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                // Handle 'F' key for entering/exiting car
                if (event.code === 'KeyF') {
                    enterExitCarByKey();
                }
            });
            window.addEventListener('keyup', (event) => { keys[event.code] = false; });
            window.addEventListener('resize', onWindowResize);
            document.body.addEventListener('mousedown', onMouseDown); // Keep for player shooting
            document.body.addEventListener('contextmenu', (event) => {
                 // Prevent context menu if pointer locked OR if in car (to avoid accidental menu on right-click exit)
                 if ((controls && controls.isLocked) || isInCar) {
                     event.preventDefault();
                 }
            });
            if (restartButton) { restartButton.addEventListener('click', restartGame); }
            listenersAdded = true; console.log("Event listeners added.");
        }

        function onMouseDown(event) {
            if (isGameOver) return;

            // --- Shooting (Left Click, only on foot) ---
            if (event.button === 0 && !isInCar && controls && controls.isLocked) {
                shoot(true); // Pass true for player bullet
                return;
            }

            // --- Enter/Exit Car (Now handled by 'F' key in keydown) ---
            // Remove right-click enter/exit logic
            // if (event.button === 2) {
            //     event.preventDefault(); // Still prevent context menu maybe? (Handled in contextmenu listener now)
            //     // enterExitCar(); // Removed
            //     return;
            // }
        }

        // --- Collision Detection ---
        function checkPlayerCollisions(delta) { /* ... (implementation unchanged) ... */
            if (!controls || isInCar) return; const playerHeight = 1.8; const playerRadius = 0.4; const playerObject = controls.getObject(); const currentPos = playerObject.position; const collisionCheckObjects = [...environmentObjects, ...enemies, ...cars];
            const groundRayOrigin = currentPos.clone().add(new THREE.Vector3(0, -playerHeight / 2 + 0.1, 0)); const downRay = new THREE.Raycaster(groundRayOrigin, new THREE.Vector3(0, -1, 0), 0, 0.2); const groundIntersects = downRay.intersectObjects(collisionCheckObjects, false); onGround = groundIntersects.length > 0;
            if (onGround) { if (playerVelocity.y < 0) { playerVelocity.y = 0; currentPos.y = groundIntersects[0].point.y + playerHeight / 2; } } else { playerVelocity.y += GRAVITY * delta; }
            const moveAmount = MOVE_SPEED * delta; let moveX = 0; let moveZ = 0; if (keys['KeyW']) moveZ += moveAmount; if (keys['KeyS']) moveZ -= moveAmount; if (keys['KeyA']) moveX -= moveAmount; if (keys['KeyD']) moveX += moveAmount;
            if (moveX !== 0) controls.moveRight(moveX); if (moveZ !== 0) controls.moveForward(moveZ); currentPos.y += playerVelocity.y * delta;
            const playerCapsule = new Capsule( new THREE.Vector3(currentPos.x, currentPos.y - playerHeight / 2 + playerRadius, currentPos.z), new THREE.Vector3(currentPos.x, currentPos.y + playerHeight / 2 - playerRadius, currentPos.z), playerRadius );
            for (const obj of collisionCheckObjects) { if (obj === playerObject || (obj.geometry && obj.geometry instanceof THREE.PlaneGeometry)) continue; const objBox = new THREE.Box3().setFromObject(obj); const intersects = playerCapsule.intersectsBox(objBox); if (intersects) { const penetration = playerCapsule.getPenetration(objBox); currentPos.add(penetration); if (penetration.y > 0 && playerVelocity.y < 0) { playerVelocity.y = 0; onGround = true; currentPos.y = objBox.max.y + playerHeight / 2; } if (penetration.y < 0 && playerVelocity.y > 0) { playerVelocity.y = 0; currentPos.y = objBox.min.y - playerHeight / 2; } } }
            if (currentPos.y < -50) { currentPos.set(0, 10, 10); playerVelocity.set(0, 0, 0); takeDamage(PLAYER_MAX_HEALTH); }
         }


        // --- Update Projectiles ---
        function updateProjectiles(delta) {
            const currentTime = clock.getElapsedTime();
            const tempBulletBox = new THREE.Box3();
            const tempEnemyBox = new THREE.Box3();
            const tempBuildingBox = new THREE.Box3();
            const tempCarBox = new THREE.Box3();
            const tempPlayerBox = new THREE.Box3(); // For enemy bullets hitting player

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const bullet = projectiles[i];
                if (!bullet || !bullet.userData || !bullet.userData.velocity) { if (bullet && scene) scene.remove(bullet); projectiles.splice(i, 1); continue; }

                const velocity = bullet.userData.velocity;
                bullet.position.addScaledVector(velocity, delta);

                if (currentTime - bullet.userData.spawnTime > BULLET_LIFETIME) { if (scene) scene.remove(bullet); projectiles.splice(i, 1); continue; }

                tempBulletBox.setFromObject(bullet);
                let hit = false;

                // --- Collision Checks ---
                if (bullet.userData.isPlayerBullet) {
                    // Player bullet hitting enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j]; if (!enemy) continue;
                        tempEnemyBox.setFromObject(enemy);
                        if (tempBulletBox.intersectsBox(tempEnemyBox)) {
                            if (enemy.userData) { enemy.userData.health -= BULLET_DAMAGE; console.log(`Enemy Hit! Health: ${enemy.userData.health}`); if (enemy.userData.health <= 0) removeEnemy(enemy); }
                            if (scene) scene.remove(bullet); projectiles.splice(i, 1); hit = true; break;
                        }
                    }
                } else {
                    // Enemy bullet hitting player (on foot or in car)
                    if (isInCar && playerCar) {
                        tempCarBox.setFromObject(playerCar);
                        if (tempBulletBox.intersectsBox(tempCarBox)) {
                            // Damage car? For now, just destroy bullet
                            console.log("Enemy bullet hit player car!");
                            if (scene) scene.remove(bullet); projectiles.splice(i, 1); hit = true;
                        }
                    } else if (!isInCar && controls) {
                        // Approximate player bounding box when on foot
                        const playerPos = controls.getObject().position;
                        tempPlayerBox.setFromCenterAndSize(playerPos, new THREE.Vector3(0.8, 1.8, 0.8)); // Approx player size
                        if (tempBulletBox.intersectsBox(tempPlayerBox)) {
                            console.log("Enemy bullet hit player!");
                            takeDamage(ENEMY_BULLET_DAMAGE);
                            if (scene) scene.remove(bullet); projectiles.splice(i, 1); hit = true;
                        }
                    }
                }
                if (hit) continue; // Skip further checks if bullet hit target

                // Check collision with environment (buildings, cars - except the player's car if it's an enemy bullet)
                const hitCheckObjects = [...environmentObjects, ...cars];
                for (const obj of hitCheckObjects) {
                     if (obj.geometry && obj.geometry instanceof THREE.PlaneGeometry) continue; // Ignore ground/roads
                     // Don't let enemy bullets hit the player's car in this check (handled above)
                     if (!bullet.userData.isPlayerBullet && obj === playerCar) continue;

                     tempBuildingBox.setFromObject(obj); // Use tempBuildingBox for any environment object/car
                     if (tempBulletBox.intersectsBox(tempBuildingBox)) {
                         if (scene) scene.remove(bullet); projectiles.splice(i, 1); hit = true; break;
                     }
                }
                 if (hit) continue;

                 if (bullet.position.y < 0) { if (scene) scene.remove(bullet); projectiles.splice(i, 1); } // Hit ground
            }
        }

        // --- Update Enemies ---
        function updateEnemies(delta) {
            if (isGameOver || !controls) return;
            const currentTime = clock.getElapsedTime();
            const playerObject = isInCar ? playerCar : controls.getObject(); // Target player or car object
            const playerPos = playerObject.position;

            enemies.forEach(enemy => {
                if (!enemy || !enemy.userData) return;

                const directionToPlayer = new THREE.Vector3().subVectors(playerPos, enemy.position);
                const distanceToPlayerSq = directionToPlayer.lengthSq();
                const distanceToPlayer = Math.sqrt(distanceToPlayerSq); // Need actual distance for range checks

                // --- Movement ---
                // Move if not too close and player is alive
                if (distanceToPlayerSq > ENEMY_ATTACK_RANGE_SQ * 1.1 && !isGameOver) {
                    const moveDirection = directionToPlayer.clone(); // Use a copy for movement
                    moveDirection.y = 0; // Move only on XZ plane
                    moveDirection.normalize();
                    enemy.position.addScaledVector(moveDirection, ENEMY_MOVE_SPEED * delta);
                }
                 // Always face the player
                 enemy.lookAt(playerPos.x, enemy.position.y, playerPos.z); // LookAt on XZ plane

                // --- Shooting Logic ---
                if (distanceToPlayer < ENEMY_SHOOT_RANGE && currentTime - enemy.userData.lastShootTime > ENEMY_SHOOT_COOLDOWN && !isGameOver) {
                    // Check line of sight before shooting
                    raycaster.set(enemy.position.clone().add(new THREE.Vector3(0, 1.0, 0)), directionToPlayer.normalize()); // Ray from enemy eye level
                    const obstacles = [...environmentObjects, ...cars]; // Objects that block shots
                    const intersects = raycaster.intersectObjects(obstacles, false); // Non-recursive check

                    let canSeePlayer = true;
                    if (intersects.length > 0) {
                        // Check if the first hit object is closer than the player
                        if (intersects[0].distance < distanceToPlayer - 1.0) { // Allow hitting if very close
                            canSeePlayer = false;
                        }
                    }

                    if (canSeePlayer) {
                        console.log("Enemy shoots!");
                        // Calculate direction slightly offset (less accurate aim)
                        const shootDirection = directionToPlayer.normalize(); //.add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.1));
                        shoot(false, enemy.position.clone().add(new THREE.Vector3(0, 1.0, 0)), shootDirection); // Shoot from eye level
                        enemy.userData.lastShootTime = currentTime; // Reset shoot cooldown
                    }
                }

                // --- Melee Attack Logic --- (If very close)
                if (distanceToPlayerSq < ENEMY_ATTACK_RANGE_SQ && currentTime - enemy.userData.lastAttackTime > ENEMY_ATTACK_COOLDOWN) {
                    console.log("Enemy melee attacks!");
                    if (!isInCar) { takeDamage(ENEMY_DAMAGE); } // Only damage player on foot
                    enemy.userData.lastAttackTime = currentTime;
                }

                // --- Collision Avoidance ---
                 const checkObjects = [...enemies, ...environmentObjects, ...cars];
                 enemyBoundingBox.setFromObject(enemy).expandByScalar(0.1);
                 for(const other of checkObjects) {
                     if (other === enemy || (other.geometry && other.geometry instanceof THREE.PlaneGeometry)) continue;
                     const otherBox = new THREE.Box3().setFromObject(other);
                     if (enemyBoundingBox.intersectsBox(otherBox)) {
                         const pushDirection = new THREE.Vector3().subVectors(enemy.position, other.position).normalize();
                         pushDirection.y = 0;
                         enemy.position.addScaledVector(pushDirection, ENEMY_MOVE_SPEED * delta * 0.5);
                         break;
                     }
                 }
            });
        }


        // --- Update & Render Loop ---
        function update(delta) {
            if (isInCar) { /* No player collision check needed */ }
            else {
                if (keys['Space'] && onGround) { playerVelocity.y = JUMP_VELOCITY; onGround = false; }
                checkPlayerCollisions(delta);
            }
            updateCars(delta);
            updateProjectiles(delta);
            updateEnemies(delta);
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);
            if (isGameOver) return;
            const delta = clock.getDelta();
            if (renderer && (!isGameOver)) { update(delta); }
            if (renderer && scene && camera) { try { renderer.render(scene, camera); } catch (e) { console.error("Error during rendering:", e); if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null; gameOver(); alert("A rendering error occurred."); } }
        }

        // --- Window Resize Handling ---
        function onWindowResize() { if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } }

        // --- Start ---
        window.onload = () => { init(); };

    </script>
</body>
</html>
